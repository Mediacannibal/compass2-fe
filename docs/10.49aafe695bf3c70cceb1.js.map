{"version":3,"sources":["webpack:///./node_modules/chart.js/dist/chart.mjs"],"names":["animator","this","_request","_charts","Map","_running","_lastDate","undefined","chart","anims","date","type","callbacks","listeners","numSteps","duration","forEach","fn","initial","currentStep","Math","min","start","call","window","_update","_refresh","Date","now","remaining","running","items","length","item","i","draw","_active","_total","tick","pop","_notify","charts","get","complete","progress","set","event","cb","_getAnims","push","reduce","acc","cur","max","_duration","cancel","delete","interpolators","boolean","from","to","factor","c0","c1","valid","mix","hexString","number","Animation","cfg","target","prop","currentValue","_fn","_easing","easing","linear","_start","floor","delay","_loop","loop","_target","_prop","_from","_to","_promises","elapsed","remain","promises","Promise","res","rej","resolved","method","animationOptions","Object","keys","animation","describe","_fallback","_indexable","_scriptable","name","colors","properties","numbers","active","resize","show","animations","visible","hide","v","Animations","config","_chart","_properties","configure","animatedProps","getOwnPropertyNames","key","option","has","values","newOptions","options","$shared","assign","$animations","resolveTargetOptions","_createAnimations","anim","wait","all","awaitAll","then","props","charAt","_animateOptions","value","update","size","add","scaleClip","scale","allowedOverflow","opts","reverse","end","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","ilen","index","applyStack","stack","dsIndex","singleMode","mode","datasetIndex","otherValue","isStacked","meta","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","controller","parsed","_cachedMeta","_stacks","iScale","iAxis","axis","vAxis","indexScale","valueScale","id","getStackKey","_top","_bottom","getFirstScaleId","scales","filter","shift","clearStacks","_parsed","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","_ctx","ctx","_cachedDataOpts","getMeta","_type","_parsing","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","_stacked","addElements","dataset","getDataset","chooseId","x","y","r","xid","xAxisID","yid","yAxisID","rid","rAxisID","indexAxis","iid","iAxisID","vid","vAxisID","xScale","getScaleForId","yScale","rScale","data","datasets","getDatasetMeta","scaleID","adata","Array","convertObjectDataToArray","isExtensible","_dataCheck","datasetElementType","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","scopes","getOptionScopes","createResolver","getContext","parsing","count","sorted","_sorted","prev","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","parse","xAxisKey","yAxisKey","range","parsedValue","NaN","canStack","otherScale","_getOtherScale","hidden","createStack","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","otherMin","otherMax","minDefined","maxDefined","getUserBounds","_skip","updateRangeFromParsed","getParsed","label","getLabelForValue","_clip","t","b","l","top","right","bottom","left","disabled","toClip","clip","defaultClip","getMaxOverflow","elements","area","chartArea","drawActiveElementsOnTop","element","resolveDatasetElementOptions","resolveDataElementOptions","context","parent","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","dataElementType","elementType","cache","cacheKey","sharing","datasetElementScopeKeys","prefixes","names","resolveNamedOptions","freeze","transition","datasetAnimationScopeKeys","_cacheable","sharedOptions","_animationsDisabled","firstOpts","previouslySharedOptions","getSharedOptions","includeOptions","updateSharedOptions","_resolveAnimations","getStyle","_setStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","arr","updateElements","removed","splice","args","_dataChanges","arguments","_sync","newCount","computeMinSampleSize","_cache","$bar","visibleMetas","concat","getAllParsedValues","sort","a","getAllScaleValues","curr","_length","updateMinAndPrev","abs","getPixelForValue","ticks","getPixelForTick","parseValue","entry","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","edge","borderSkipped","horizontal","base","borderProps","enableBorderRadius","parseEdge","orig","v1","v2","startEnd","setInflateAmount","inflateAmount","ratio","defaults","prototype","BarController","iAxisKey","vAxisKey","obj","super","bars","reset","getBasePixel","isHorizontal","ruler","_getRuler","_getSharedOptions","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","center","height","width","updateElement","last","grouped","skipNull","val","isNaN","indexOf","_getStacks","pixels","barThickness","_startPixel","_endPixel","stackCount","_getStackCount","categoryPercentage","barPercentage","baseValue","minBarLength","actualBase","floating","getDataVisibility","barSign","startPixel","getPixelForDecimal","endPixel","halfGrid","getLineWidthForValue","maxBarThickness","Infinity","next","percent","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","_getStackIndex","rects","overrides","_index_","offset","grid","_value_","beginAtZero","BubbleController","radius","points","point","iPixel","vPixel","skip","plugins","tooltip","title","DoughnutController","innerRadius","outerRadius","offsetX","offsetY","getter","rotation","circumference","isDatasetVisible","_getRotation","_getCircumference","arcs","spacing","getMaxBorderWidth","getMaxOffset","maxSize","cutout","chartWeight","_getRingWeight","_getRotationExtents","ratioX","ratioY","startAngle","endAngle","startX","cos","startY","sin","endX","endY","calcMax","angle","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxWidth","maxHeight","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","animateRotate","calculateCircumference","animationOpts","centerX","centerY","animateScale","_circumference","arc","metaData","locale","borderAlign","borderWidth","hoverBorderWidth","hoverOffset","ringWeightOffset","weight","descriptors","aspectRatio","legend","pointStyle","map","style","text","fillStyle","backgroundColor","strokeStyle","borderColor","lineWidth","e","legendItem","toggleDataVisibility","tooltipItem","dataLabel","formattedValue","slice","LineController","line","_dataset","animationsDisabled","_datasetIndex","_decimated","showLine","segment","animated","spanGaps","maxGapLength","directUpdate","prevParsed","nullData","stop","border","firstPoint","lastPoint","updateControlPoints","PolarAreaController","bind","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","angleLines","display","circular","pointLabels","PieController","RadarController","_fullLoop","pointPosition","getPointPositionForValue","fill","Element","useFinalPosition","getProps","final","ret","defaultRoutes","formatters","tickValue","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","format","pow","numeric","Ticks","autoSkip","tickOpts","ticksLimit","maxTicksLimit","tickLength","_tickSize","maxScale","maxChart","_maxLength","determineMaxTicks","majorIndices","major","enabled","result","getMajorIndices","numMajorIndices","first","newTicks","ceil","skipMajors","evenMajorSpacing","len","diff","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","round","majorStart","majorEnd","bounds","grace","drawBorder","drawOnChartArea","drawTicks","tickWidth","tickColor","color","borderDash","borderDashOffset","padding","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkipPadding","labelOffset","callback","minor","align","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","route","startsWith","offsetFromEdge","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","fallback","font","lineHeight","titleAlign","position","reverseAlign","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_reversePixels","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","setContext","suggestedMin","suggestedMax","metas","getMinMax","xLabels","yLabels","beforeUpdate","margins","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","notifyPlugins","_callHooks","beforeTickToLabelConversion","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","sqrt","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","fullSize","generateTickLabels","_computeLabelSizes","caches","widths","heights","j","jlen","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","string","gc","gcLen","garbageCollect","valueAt","idx","pixel","decimal","getBaseValue","createTickContext","optionTicks","rot","w","h","ticksLength","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","limit","step","optsAtIndex","lineColor","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","textAlign","lineCount","textOffset","textBaseline","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","strokeColor","strokeWidth","backdrop","tickTextAlign","labelPadding","translation","save","fillRect","restore","findIndex","_computeGridLineItems","drawLine","p1","p2","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","lastLineWidth","_computeLabelArea","_computeLabelItems","titleX","titleY","titleArgs","drawBackground","drawGrid","drawTitle","drawLabels","tz","z","gz","getSortedVisibleDatasetMetas","axisID","fontSize","TypedRegistry","scope","override","create","isPrototypeOf","proto","getPrototypeOf","parentScope","isIChartComponent","register","Error","itemDefaults","routes","property","propertyParts","split","sourceName","sourceScope","join","parts","targetName","targetScope","routeDefaults","registerDefaults","registry","controllers","_typedRegistries","_each","_get","typedRegistry","arg","reg","_getRegistryForType","isForType","_exec","itemReg","component","camelMethod","ScatterController","getElement","interaction","__proto__","abstract","DateAdapter","chartOptions","timestamp","amount","unit","weekday","members","adapters","_date","binarySearch","metaset","intersect","lookupMethod","el","getRange","lo","hi","evaluateInteractionItems","handler","getIntersectItems","includeInvisible","isPointInArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","pt1","pt2","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getCenterPoint","distance","getNearestItems","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","STATIC_POSITIONS","filterByPosition","array","pos","filterDynamicPositionByAxis","box","sortByWeight","v0","setLayoutDims","layouts","params","wrap","stackWeight","includes","_stack","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","layout","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","other","getMargins","marginForPositions","positions","margin","fitBoxes","boxes","refitBoxes","refit","changed","setBoxDims","placeBoxes","userPadding","autoPadding","_layers","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","updatePos","change","handleMaxPadding","BasePlatform","canvas","listener","BasicPlatform","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","passive","removeListener","removeEventListener","nodeListContains","nodeList","node","contains","createAttachObserver","observer","MutationObserver","entries","trigger","addedNodes","removedNodes","observe","document","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","devicePixelRatio","currentDevicePixelRatio","createResizeObserver","container","clientWidth","ResizeObserver","contentRect","addEventListener","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","proxy","native","fromNativeEvent","addListener","DomPlatform","renderHeight","getAttribute","renderWidth","boxSizing","displayWidth","displayHeight","initCanvas","removeAttribute","setAttribute","proxies","$proxies","attach","detach","isConnected","PluginService","_init","hook","_createDescriptors","_descriptors","descriptor","plugin","cancelable","_oldCache","_notifyStateChanges","localIds","getPlugin","local","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","some","pluginScopeKeys","scriptable","indexable","allKeys","getIndexAxis","datasetDefaults","determineAxis","scaleOptions","toLowerCase","initOptions","chartDefaults","configScales","chartIndexAxis","firstIDs","scaleConf","console","error","_proxy","warn","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","mergeScaleConfig","initData","keyCache","keysCached","Set","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","platform","clearCache","clear","datasetType","additionalOptionScopes","mainScope","resetCache","keyLists","_cachedScopes","resolver","subPrefixes","getResolver","isScriptable","isIndexable","hasFunction","needContext","subResolver","descriptorDefaults","resolverCache","p","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","c","moveNumericKeys","intKey","Chart","userConfig","initialCanvas","existingChart","chartOptionScopes","OffscreenCanvas","_detectPlatform","updateConfig","acquireContext","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","listen","_initialize","maintainAspectRatio","responsive","bindEvents","_resizeBeforeDraw","_resize","newSize","getMaximumSize","newRatio","getDevicePixelRatio","onResize","render","scalesOptions","axisOptions","scaleOpts","updated","isRadial","dposition","dtype","scaleType","getScale","init","hasUpdated","addBox","_destroyDatasetMeta","newControllers","_removeUnreferencedMetasets","order","updateIndex","ControllerClass","getController","_updateMetasets","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","invalidate","buildOrUpdateControllers","buildOrUpdateElements","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","removeBox","ensureScalesHaveIDs","buildOrUpdateScales","existingEvents","newEvents","events","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","useClip","setDatasetVisibility","_updateVisibility","_destroy","remove","_stop","releaseContext","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","isAttached","prefix","activeElements","lastActive","notify","replay","hoverOptions","hover","deactivated","activated","updateHoverStyle","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","lastEvent","determineLastEvent","onHover","onClick","getElementsAtEventForMode","invalidatePlugins","clipArc","pixelMargin","angleMargin","closePath","parseBorderRadius$1","angleDelta","o","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","innerR","spacingOffset","alpha","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","pCenter","p4","PI","p8","outerStartX","outerStartY","outerEndX","outerEndY","borderJoinStyle","inner","lineJoin","fullCircles","drawFullCircleBorders","defineProperties","enumerable","version","unregister","ArcElement","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","translate","drawArc","setStyle","lineCap","borderCapStyle","previous","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","tension","cubicInterpolationMode","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","path","_path","strokePathWithCache","segments","segmentMethod","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","_interpolate","_getInterpolationMethod","interpolated","inRange$1","hitRadius","capBezierPoints","PointElement","mouseX","mouseY","hoverRadius","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","topLeft","topRight","bottomLeft","bottomRight","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","rect","inflateRect","refRect","BarElement","addRectPath","cleanDecimatedDataset","defineProperty","cleanDecimatedData","plugin_decimation","algorithm","beforeElementsUpdate","xAxis","pointCount","getStartAndCountOfVisiblePointsSimplified","threshold","decimated","configurable","d","samples","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_pointsFromSegments","_shouldApplyFill","_resolveTarget","sources","propagate","visited","_decodeFill","fillOption","parseFillOption","parseFloat","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","unshift","interpolate","pointValue","firstValue","lastValue","simpleArc","_getTarget","getLineByIndex","sourcePoints","below","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","above","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","_args","$filler","drawTime","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","generateLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","itemWidth","measureText","heightLimit","totalWidth","currentColWidth","currentColHeight","col","rtl","rtlHelper","hitbox","leftForLtr","_draw","defaultColor","fontColor","halfFontSize","cursor","textDirection","textWidth","setWidth","lineDash","drawOptions","SQRT2","xPlus","yBoxTop","xBoxLeft","drawLegendBox","strikethrough","fillText","titleFont","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","onLeave","isListened","hoveredItem","_getLegendItemAt","sameItem","plugin_legend","_element","adjustHitBoxes","handleEvent","ci","Title","_padding","textSize","fontOpts","_drawArgs","plugin_title","titleBlock","createTitle","WeakMap","plugin_subtitle","positioners","hasValue","tooltipPosition","eventPosition","nearestElement","tp","pushOrConcat","toPush","apply","splitNewlines","str","String","createTooltipItem","getLabelAndValue","getTooltipSize","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","cornerRadius","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","beforeTitle","afterTitle","bodyItems","scoped","beforeLabel","afterLabel","beforeFooter","afterFooter","itemSort","labelColor","labelPointStyle","labelTextColor","_createItems","getTitle","getBeforeBody","getBody","getAfterBody","getFooter","positionAndSize","backgroundPoint","external","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","pt","titleColor","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","bodyColor","_drawColorBox","footerAlign","footerColor","tooltipSize","drawCaret","quadraticCurveTo","animX","animY","_updateAnimationTarget","hasTooltipContent","globalAlpha","drawBody","drawFooter","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","_willRender","labelCount","Decimation","Filler","SubTitle","findOrAddLabel","addedLabels","addIfString","lastIndexOf","CategoryScale","_startValue","_valueRange","_addedLabels","added","isFinite","getDecimalForPixel","relativeLabelSize","minSpacing","rad","LinearScaleBase","_endValue","setMin","setMax","minSign","maxSign","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","maxTicks","stepSize","computeTickLimit","getTickLimit","generationOptions","dataRange","precision","maxDigits","includeBounds","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks$1","_maxDigits","LinearScale","handleTickRangeOptions","isMajor","tickVal","LogarithmicScale","_zero","exp","m","endExp","endSignificand","significand","lastTick","generateTicks","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","updateLimits","setCenterPoint","_pointLabelItems","extra","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","buildPointLabelItems","hLimits","vLimits","pathRadiusLine","logarithmic","RadialLinearScale","leftMovement","rightMovement","topMovement","bottomMovement","angleMultiplier","scalingFactor","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","backdropLeft","backdropTop","backdropWidth","backdropHeight","drawPointLabels","gridLineOpts","drawRadiusLine","rotate","animate","INTERVALS","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","input","adapter","_adapter","parser","isoWeekday","_parseOpts","startOf","determineUnitForAutoTicks","minUnit","capacity","interval","addTick","time","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","_unit","_majorUnit","_offsets","_normalized","displayFormats","formats","normalized","_applyBounds","_getLabelBounds","endOf","getLabelTimestamps","timeOpts","_generate","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","hasWeekday","getDataTimestamps","tooltipFormat","datetime","minorFormat","majorFormat","formatter","_tickFormatFunction","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","_getLabelSize","normalize","table","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","registerables"],"mappings":"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","file":"10.49aafe695bf3c70cceb1.js","sourcesContent":["/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, d as defaults, i as isObject, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as createContext, j as defined, s as sign, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as log10, A as _factorize, B as finiteOrDefault, C as callback, D as _addGrace, E as _limitValue, F as toDegrees, G as _measureText, I as _int16Range, J as _alignPixel, K as toPadding, L as clipArea, M as renderText, N as unclipArea, O as toFont, Q as each, R as _toLeftRightCenter, S as _alignStartEnd, U as overrides, V as merge, W as _capitalize, X as getRelativePosition, Y as _rlookupByKey, Z as _lookupByKey, $ as _isPointInArea, a0 as getAngleFromPoint, a1 as getMaximumSize, a2 as _getParentNode, a3 as readUsedSize, a4 as throttled, a5 as supportsEventListenerOptions, a6 as _isDomSupported, a7 as descriptors, a8 as isFunction, a9 as _attachContext, aa as _createResolver, ab as _descriptors, ac as mergeIf, ad as uid, ae as debounce, af as retinaScale, ag as clearCanvas, ah as setsEqual, ai as _elementsEqual, aj as _isClickEvent, ak as _isBetween, al as _readValueToProps, am as _updateBezierControlPoints, an as _computeSegments, ao as _boundSegments, ap as _steppedInterpolation, aq as _bezierInterpolation, ar as _pointInLine, as as _steppedLineTo, at as _bezierCurveTo, au as drawPoint, av as addRoundedRectPath, aw as toTRBL, ax as toTRBLCorners, ay as _boundSegment, az as _normalizeAngle, aA as getRtlAdapter, aB as overrideTextDirection, aC as _textX, aD as restoreTextDirection, aE as drawPointLegend, aF as noop, aG as distanceBetweenPoints, aH as _setMinAndMaxByKey, aI as niceNum, aJ as almostWhole, aK as almostEquals, aL as _decimalPlaces, aM as _longestText, aN as _filterBetween, aO as _lookup } from './chunks/helpers.segment.mjs';\nexport { d as defaults } from './chunks/helpers.segment.mjs';\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = color(from || transparent);\n    const c1 = c0.valid && color(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\ndefaults.describe('animations', {\n  _fallback: 'animation',\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n    return range;\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\ndefaults.describe('scales', {\n  _fallback: 'scale',\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    callback(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndex.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n      if (isHorizontal) {\n        x = pixel;\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign: tickTextAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n  defaults.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass ScatterController extends DatasetController {\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    if (this.options.showLine) {\n      const {dataset: line, _dataset} = meta;\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    }\n    this.updateElements(points, start, count, mode);\n  }\n  addElements() {\n    const {showLine} = this.options;\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = registry.getElement('line');\n    }\n    super.addElements();\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  init(chartOptions) {}\n  formats() {\n    return abstract();\n  }\n  parse(value, format) {\n    return abstract();\n  }\n  format(timestamp, format) {\n    return abstract();\n  }\n  add(timestamp, amount, unit) {\n    return abstract();\n  }\n  diff(a, b, unit) {\n    return abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return abstract();\n  }\n  endOf(timestamp, unit) {\n    return abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  evaluateInteractionItems,\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\ndefaults.set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n  return {plugins, localIds};\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {},\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.9.1\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    callback(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      unclipArea(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n    this.notifyPlugins('afterDestroy');\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    each(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      callback(options.onHover, [e, active, this], this);\n      if (isClick) {\n        callback(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\nconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  if (circular) {\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n  const {options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const inner = options.borderAlign === 'inner';\n  if (!borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderJoinStyle: undefined,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n  circular: true,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n  return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (!meta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = _boundSegments(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\nfunction _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n  return target;\n}\nfunction _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n  let value;\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n\nfunction _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n\nfunction _getTarget(source) {\n  const {chart, fill, line} = source;\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n  if (isNumberFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n  return null;\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nvar index = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n      this._draw();\n      unclipArea(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    overrideTextDirection(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = _alignStartEnd(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart || config._chart;\n    this._chart = this.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : (labelColors.borderWidth || 1);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      each(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n        return;\n      }\n      tooltip.draw(chart.ctx);\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? min : 0;\n    this.max = isNumberFinite(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const extra = getTickBackdropHeight(opts) / 2;\n  const outerDistance = scale.drawingArea;\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!isNullOrUndef(backdropColor)) {\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      const backdropLeft = left - padding.left;\n      const backdropTop = top - padding.top;\n      const backdropWidth = right - left + padding.width;\n      const backdropHeight = bottom - top + padding.height;\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: backdropLeft,\n          y: backdropTop,\n          w: backdropWidth,\n          h: backdropHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n      }\n    }\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5,\n    centerPointLabels: false\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    adapter.init(opts);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = _filterBetween(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, elements, layouts, plugins, registerables, registry, scales };\n"],"sourceRoot":""}